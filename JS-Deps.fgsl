// JS-Deps: Node Package Manager Dependency Graph
//
// Nodes are packages. Edges are directed from a package to its dependencies.

#pragma fg attribute(float X[N])
#pragma fg attribute(float Y[N])
#pragma fg attribute(uint Date[N])
#pragma fg attribute(uint Devs[N])
#pragma fg attribute(uint Vuln[N])

#define NOV_09_2010 1289278800
#define MAR_22_2016 1458619200

#define JAN_01_2011 1293858000
#define JAN_01_2012 1325394000
#define JAN_01_2013 1357016400
#define JAN_01_2014 1388552400
#define JAN_01_2015 1420088400
#define JAN_01_2016 1451624400

// Some controls
#pragma fg define(USE_COLOR)
#pragma fg define(USE_FILTER)
#pragma fg define(USE_RELATIONAL)


#pragma fg shader(positional)
void main() {
    float x = X[fg_NodeIndex];
    float y = Y[fg_NodeIndex];

    fg_NodePosition = vec3(x, y, 0);
}


#pragma fg shader(relational)
void main() {
    #pragma fg scratch(uint in_degree[N])
    #pragma fg scratch(uint out_degree[N])
    #pragma fg scratch(atomic_uint in_degree_max)
    #pragma fg scratch(atomic_uint out_degree_max)

    #pragma fg define(USE_RELATIONAL 1)
    #if USE_RELATIONAL
    uint od = 1 + atomicAdd(out_degree[fg_SourceIndex], 1);
    atomicCounterMax(out_degree_max, od);

    uint id = 1 + atomicAdd(in_degree[fg_TargetIndex], 1);
    atomicCounterMax(in_degree_max, id);
    #endif /* USE_RELATIONAL */
}


#pragma fg shader(appearance)
void main() {
    #pragma fg scratch(uint Seen[E])
    bool first = 0 == atomicAdd(Seen[fg_EdgeIndex], 1);
    bool d = false;

    #pragma fg scratch(atomic_uint total)
    if (first) atomicCounterAdd(total, 1);

    #pragma fg define(FILTER_BY_DATE 1)
    #if FILTER_BY_DATE
    #pragma fg define(LO JAN_01_2014)
    #pragma fg define(HI JAN_01_2015)

    if (Date[fg_SourceIndex] < LO) {
        d = true;
        #pragma fg scratch(atomic_uint source_date_too_lo)
        if (first) atomicCounterAdd(source_date_too_lo, 1);
    }

    if (Date[fg_SourceIndex] > HI) {
        d = true;
        #pragma fg scratch(atomic_uint source_date_too_hi)
        if (first) atomicCounterAdd(source_date_too_hi, 1);
    }

    if (Date[fg_TargetIndex] < LO) {
        d = true;
        #pragma fg scratch(atomic_uint target_date_too_lo)
        if (first) atomicCounterAdd(target_date_too_lo, 1);
    }

    if (Date[fg_TargetIndex] > HI) {
        d = true;
        #pragma fg scratch(atomic_uint target_date_too_hi)
        if (first) atomicCounterAdd(target_date_too_hi, 1);
    }
    #endif /* FILTER_BY_DATE */

    if (d) {
        #pragma fg scratch(atomic_uint discarded)
        if (first) atomicCounterAdd(discarded, 1);
        discard;
    } else {
        #pragma fg scratch(atomic_uint kept)
        if (first) atomicCounterAdd(kept, 1);
    }

    bool vuln = bool(Vuln[fg_SourceIndex]) || bool(Vuln[fg_TargetIndex]);
    bool risky = Devs[fg_SourceIndex] > Devs[fg_TargetIndex];

    #if USE_RELATIONAL
    const uint depends_on_source = in_degree[fg_SourceIndex];
    const uint depends_on_target = in_degree[fg_TargetIndex];

    risky = depends_on_source + depends_on_target > 100 * Devs[fg_TargetIndex];
    #endif /* USE_RELATIONAL */

    if (risky) {
        #pragma fg scratch(atomic_uint total_risky)
        if (first) atomicCounterAdd(total_risky, 1);
    }

    if (risky && vuln) {
        #pragma fg scratch(atomic_uint total_vuln_and_risky)
        if (first) atomicCounterAdd(total_vuln_and_risky, 1);
    }

    if (vuln) {
        #pragma fg scratch(atomic_uint total_vuln)
        if (first) atomicCounterAdd(total_vuln, 1);
    }

    fg_FragColor = vec4(0.1);
    fg_FragColor.r = float(vuln);
    fg_FragColor.b = float(risky);
}
