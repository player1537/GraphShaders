{% if not preprocessed %}
#define edge(...) edge(in vec2 fg_FragCoord, in float fg_FragDepth, in vec4 fg_EdgeData, ## __VA_ARGS__, out vec4 fg_EdgeColor, inout bool fg_Discard)
#define discard fg_Discard = true
uniform vec3 uCat6[6];
{% else %}
#version 460 core
#define fg_EdgeID (global_indices[gl_PrimitiveID] + 1)
precision mediump float;

// DO NOT USE A VEC 3 IN THESE. CHECK: https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)
// Memory Layout Section for more details! Specifically, std140 v std430 and how _VEC 3 IS STILL
// TREATED THE SAME_.
// This should be somewhat tolerant to the user program? I have no clue how to make this flexible...
struct EdgeData {
    vec4 color;
};

layout(std430, binding = 0) readonly buffer GlobalEdgeData {
    EdgeData global_edge_data[];
};

layout(std430, binding = 1) readonly buffer PrimitiveLookasideBuffer {
    int global_indices[];
};

{% endif %}

{% if preprocessed %}

const vec3 Blues[5] = vec3[5](
    vec3(239., 243., 255.) / 255.,
    vec3(189., 215., 231.) / 255.,
    vec3(107., 174., 214.) / 255.,
    vec3( 49., 130., 189.) / 255.,
    vec3(  8.,  81., 156.) / 255.);
const vec3 Greens[5] = vec3[5](
    vec3(237., 248., 233.) / 255.,
    vec3(186., 228., 179.) / 255.,
    vec3(116., 196., 118.) / 255.,
    vec3( 49., 163.,  84.) / 255.,
    vec3(  0., 109.,  44.) / 255.);
const vec3 Greys[5] = vec3[5](
    vec3(247., 247., 247.) / 255.,
    vec3(204., 204., 204.) / 255.,
    vec3(150., 150., 150.) / 255.,
    vec3( 99.,  99.,  99.) / 255.,
    vec3( 37.,  37.,  37.) / 255.);
const vec3 Oranges[5] = vec3[5](
    vec3(254., 237., 222.) / 255.,
    vec3(253., 190., 133.) / 255.,
    vec3(253., 141.,  60.) / 255.,
    vec3(230.,  85.,  13.) / 255.,
    vec3(166.,  54.,   3.) / 255.);
const vec3 Purples[5] = vec3[5](
    vec3(242., 240., 247.) / 255.,
    vec3(203., 201., 226.) / 255.,
    vec3(158., 154., 200.) / 255.,
    vec3(117., 107., 177.) / 255.,
    vec3( 84.,  39., 143.) / 255.);
const vec3 Reds[5] = vec3[5](
    vec3(254., 229., 217.) / 255.,
    vec3(252., 174., 145.) / 255.,
    vec3(251., 106.,  74.) / 255.,
    vec3(222.,  45.,  38.) / 255.,
    vec3(165.,  15.,  21.) / 255.);

uniform float uNodeMin1, uNodeMin2, uNodeMin3, uNodeMin4, uNodeMin5, uNodeMin6, uNodeMin7, uNodeMin8;
uniform float uNodeMax1, uNodeMax2, uNodeMax3, uNodeMax4, uNodeMax5, uNodeMax6, uNodeMax7, uNodeMax8;
uniform float uEdgeMin1, uEdgeMin2, uEdgeMin3, uEdgeMin4, uEdgeMin5, uEdgeMin6, uEdgeMin7, uEdgeMin8;
uniform float uEdgeMax1, uEdgeMax2, uEdgeMax3, uEdgeMax4, uEdgeMax5, uEdgeMax6, uEdgeMax7, uEdgeMax8;
{% endif %}

{% if not preprocessed %}
{{ source|safe }}
{% else %}
{{ source|replace(" flat ", " ")|replace(" unit ", " float ")|safe }}
{% endif %}

{% if preprocessed %}
uniform float uTranslateX, uTranslateY, uScale;

{% for param in params_from_node | selectattr("storage", "in", ("in",)) -%}
{{ param.storage }} {% if param.qualifier %}{{ param.qualifier }} {% endif %}{{ param.type | replace("unit", "float") }} {{ param.name }};
{% endfor %}

{% for param in params_from_edge | selectattr("storage", "in", ("out",)) -%}
{{ param.storage }} {{ param.type }} {{ param.name }};
{% endfor %}

void main() {
    vec4 fg_EdgeData = global_edge_data[global_indices[gl_PrimitiveID] + 1].color;
    bool fg_Discard = false;
    edge(
        {%- for param in params_from_node | selectattr("storage", "in", ("in",)) -%}
        {%- if not loop.first %}, {% endif %}
        {{ param.name }}
        {%- endfor -%}
        {%- for param in params_from_edge | selectattr("storage", "in", ("in",)) -%},
        {%- if param.type == "float" -%}
        fg_EdgeData[{{ loop.index0 }}]
        {%- elif param.type == "unit" -%}
        (fg_EdgeData[{{ loop.index0 }}] - uEdgeMin{{ loop.index }}) / (uEdgeMax{{ loop.index }} - uEdgeMin{{ loop.index }})
        {%- elif param.type == "int" -%}
        int(fg_EdgeData[{{ loop.index0 }}])
        {%- endif %}
        {%- endfor -%}
        {% for param in params_from_edge | selectattr("storage", "in", ["inout", "out"]) -%},
        {{ param.name -}}
        {% endfor %}
    );

    if (fg_Discard) {
        discard;
    }
}

{% for param in params_from_node -%}
/** [{{ loop.index0 }}] = {{ param }} */
{# -#}
{% endfor %}
/** params_from_edge */
{% for param in params_from_edge -%}
{# -#}
/** [{{ loop.index0 }}] = {{ param }} */
{%- endfor %}
{% endif %}
