<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>FG</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css"
   integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ=="
   crossorigin="">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.css">
<link rel="stylesheet" href="https://unpkg.com/dat.gui@0.7.7/build/dat.gui.css">
<style>
* {
	margin: auto;
	padding: auto;
	box-sizing: border-box;
}

#map {
	width: 100vw; 
	height: 100vh;
}

.dg.ac {
	z-index: 9999999 !important;
}
</style>
<body>
<div id="map"></div>
<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"
   integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw=="
   crossorigin=""></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.js"></script>
<script src="https://unpkg.com/dat.gui@0.7.7/build/dat.gui.min.js"></script>

<script src="static/shaders.js"></script>
<script>
const gui = new dat.GUI();
const params = {
	selector: 0.5,
};
gui.add(params, 'selector', 0.0, 1.0).onChange(update);


function uuidv4() {
	return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
		(c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
	);
}

let _mabLogHost;
function mabContext(task, levels, continued) {
	this.task = task;
	this.levels = levels;
	this.continued = continued;
}
Object.assign(mabContext.prototype, {
	action: mabLogAction,
	message: mabLogMessage,
	forward: mabLogForward,
	end: mabLogEnd,
	write: mabWrite,
});


function mabWrite(task, levels, now, name, value) {
	const log = encodeURI(`${task}/${levels.join('/')}\t${now}\t${name}\t${value}`);
	console.log({ log });
	return fetch(`//${_mabLogHost}/log/${log}`, {
		method: 'POST',
	}).then((r) => r.text());
}


function mabLogToServer(host) {
	_mabLogHost = host;
	return new mabContext(null, [], false);
}

function mabLogAction(message) {
	const now = Date.now() / 1000.0;
	if (this.levels.length === 0) {
		this.task = uuidv4();
		this.levels = [1];
	} else {
		if (!this.continued) {
			this.levels = [...this.levels];
			this.levels[this.levels.length-1]++;
		} else this.continued = false;
		this.levels = [...this.levels, 1];
	}

	return this.write(this.task, this.levels, now, "@started", message);
}

function mabLogMessage(name, message) {
	const now = Date.now() / 1000.0;
	if (this.continued) console.error('after continuing, start an action, not a log message');
	this.levels = [...this.levels];
	this.levels[this.levels.length-1]++;

	return this.write(this.task, this.levels, now, name, message);
}

function mabLogForward() {
	this.levels = [...this.levels];
	this.levels[this.levels.length-1]++;
	return `${this.task}/${this.levels.join('/')}`;
}

function mabLogContinue(info) {
	const task = info.substring(0, 36);
	const levels = info.substring(37);
	return new mabContext(task, levels.split('/').map((d) => +d), true);
}

function mabLogEnd(message='') {
	const ret = this.message('@finished', message);
	this.levels = [...this.levels];
	this.levels.pop();
	return ret;
}


const log = mabLogToServer(window.location.host);
log.action('my action');
log.message('my log', 'value');
log.action('subaction');
log.message('sub', 'new value');
const info = log.forward();
log.end('final value');
log.end();

const newlog = mabLogContinue(info);
newlog.action('continued action');
newlog.message('continued message', 'value');
newlog.end();


if (false) {

const map = L.map('map', {
        crs: L.CRS.Simple,
        center: [0, 0],
        zoom: 4,
        tms: true,
        fadeAnimation: false
});

let tiles = L.tileLayer(makeUrlTemplate(), {
        tileSize: 256,
	//vert: btoa(vertexShader),
	//frag: btoa(fragmentShader)
}).addTo(map);

function update() {
	tiles.setUrl(makeUrlTemplate());
}

function makeUrlTemplate() {
	const parts = {
	dataset: window.location.hash.substring(1) || 'knit-graph',
	vert: btoa(`
#version 130

precision mediump float;

in float x;
in float y;
in float date;
in float nmaintainers;
in float cve;

uniform int pass;//?

uniform float uTranslateX;
uniform float uTranslateY;
uniform float uScale;
out float attrib;
out vec2 pos;

float rand(vec2 co){
        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float mapDate0to1(float date) { return (date - 1289345768. ) / (1458604773. - 1289345768.); }

void main(){
	vec2 aPos = vec2(x,y);	
	//attrib=rand(aPos) * 0.5;
	attrib = 1.0 - abs(mapDate0to1(date) - ${params.selector});

	vec4 temp = vec4(
		2. * (uScale * aPos.x + uTranslateX) - 1.,
		2. * (uScale * aPos.y + uTranslateY) - 1.,
        -1.0,
		1.0f
	);
    pos = aPos;
    gl_Position = temp;
}
`),
	frag: btoa(`
#version 130
	
precision mediump float;

in float attrib;
in vec2 pos;

uniform float uTranslateX;
uniform float uTranslateY;
uniform float uScale;
uniform int pass;
uniform sampler2D screenTexture;

vec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
  vec4 color = vec4(0.0);
  vec2 off1 = vec2(1.411764705882353) * direction;
  vec2 off2 = vec2(3.2941176470588234) * direction;
  vec2 off3 = vec2(5.176470588235294) * direction;
  color += texture2D(image, uv) * 0.1964825501511404;
  color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;
  color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;
  color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;
  color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;
  color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;
  color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;
  return color;
}

const float offset = 1.0 / 128.0;
void main(){
    if (pass == 1) {
        gl_FragColor = vec4(1.0, 1.0f, 1.0f, 0.8);
    } else  {

	
		vec2 offsets[9] = vec2[](
			vec2(-offset,  offset), // top-left
			vec2( 0.0f,    offset), // top-center
			vec2( offset,  offset), // top-right
			vec2(-offset,  0.0f),   // center-left
			vec2( 0.0f,    0.0f),   // center-center
			vec2( offset,  0.0f),   // center-right
			vec2(-offset, -offset), // bottom-left
			vec2( 0.0f,   -offset), // bottom-center
			vec2( offset, -offset)  // bottom-right    
		);

        float kernel[9] = float[](
            1.0 / 16, 2.0 / 16, 1.0 / 16,
            2.0 / 16, 4.0 / 16, 2.0 / 16,
            1.0 / 16, 2.0 / 16, 1.0 / 16  
        );

		vec2 texCoords = pos * uScale;
        float radius = 1.0;

        vec3 sampleTex[9];
        for(int i = 0; i < 9; i++)
        {
            //sampleTex[i] = vec3(texture(screenTexture, texCoords.st + offsets[i]));
            sampleTex[i] = blur13(screenTexture, texCoords, vec2(256, 256), vec2(radius, 0)).xyz;
        }
        vec3 col = vec3(0.0);
        for(int i = 0; i < 9; i++)
            col += sampleTex[i] * kernel[i];
        
        vec3 mix = attrib * vec3(1.0, 0.0, 0.0) + (1.0 - attrib) * col;
        gl_FragColor = vec4(mix, attrib * 2.0);

    }
}
`),

	};

	return `tile/${parts.dataset},vert,base64:${parts.vert},frag,base64:${parts.frag}-{z}-{x}-{y}`;
}
}
</script>
